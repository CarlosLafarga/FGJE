{"remainingRequest":"C:\\Users\\USUARIO\\Documents\\FGJE\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!C:\\Users\\USUARIO\\Documents\\FGJE\\node_modules\\ngx-toastr\\fesm5\\ngx-toastr.js","dependencies":[{"path":"C:\\Users\\USUARIO\\Documents\\FGJE\\node_modules\\ngx-toastr\\fesm5\\ngx-toastr.js","mtime":499162500000},{"path":"C:\\Users\\USUARIO\\Documents\\FGJE\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1528147424000},{"path":"C:\\Users\\USUARIO\\Documents\\FGJE\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":499162500000}],"contextDependencies":[],"result":["/** PURE_IMPORTS_START tslib,_angular_core,rxjs,_angular_platform_browser,_angular_animations,_angular_common PURE_IMPORTS_END */\nimport { __extends, __values } from 'tslib';\nimport { ApplicationRef, ComponentFactoryResolver, Injectable, Directive, ElementRef, NgModule, InjectionToken, Inject, Injector, NgZone, SecurityContext, Component, HostBinding, HostListener, Optional, SkipSelf } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { DomSanitizer } from '@angular/platform-browser';\nimport { animate, state, style, transition, trigger } from '@angular/animations';\nimport { CommonModule } from '@angular/common';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * A `ComponentPortal` is a portal that instantiates some Component upon attachment.\n * @template T\n */\nvar ComponentPortal = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} component\n     * @param {?} injector\n     */\n    function ComponentPortal(component, injector) {\n        this.component = component;\n        this.injector = injector;\n    }\n    /**\n     * Attach this portal to a host.\n     * @param {?} host\n     * @param {?} newestOnTop\n     * @return {?}\n     */\n    ComponentPortal.prototype.attach = function (host, newestOnTop) {\n        this._attachedHost = host;\n        return host.attach(this, newestOnTop);\n    };\n    /**\n     * Detach this portal from its host\n     * @return {?}\n     */\n    ComponentPortal.prototype.detach = function () {\n        var /** @type {?} */ host = this._attachedHost;\n        if (host) {\n            this._attachedHost = undefined;\n            return host.detach();\n        }\n    };\n    Object.defineProperty(ComponentPortal.prototype, \"isAttached\", {\n        /**\n         * Whether this portal is attached to a host.\n         * @return {?}\n         */\n        get: function () {\n            return this._attachedHost != null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Sets the PortalHost reference without performing `attach()`. This is used directly by\n     * the PortalHost when it is performing an `attach()` or `detach()`.\n     * @param {?=} host\n     * @return {?}\n     */\n    ComponentPortal.prototype.setAttachedHost = function (host) {\n        this._attachedHost = host;\n    };\n    return ComponentPortal;\n}());\n/**\n * Partial implementation of PortalHost that only deals with attaching a\n * ComponentPortal\n * @abstract\n */\nvar BasePortalHost = /*@__PURE__*/ (function () {\n    function BasePortalHost() {\n    }\n    /**\n     * @param {?} portal\n     * @param {?} newestOnTop\n     * @return {?}\n     */\n    BasePortalHost.prototype.attach = function (portal, newestOnTop) {\n        this._attachedPortal = portal;\n        return this.attachComponentPortal(portal, newestOnTop);\n    };\n    /**\n     * @return {?}\n     */\n    BasePortalHost.prototype.detach = function () {\n        if (this._attachedPortal) {\n            this._attachedPortal.setAttachedHost();\n        }\n        this._attachedPortal = undefined;\n        if (this._disposeFn) {\n            this._disposeFn();\n            this._disposeFn = undefined;\n        }\n    };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    BasePortalHost.prototype.setDisposeFn = function (fn) {\n        this._disposeFn = fn;\n    };\n    return BasePortalHost;\n}());\n/**\n * A PortalHost for attaching portals to an arbitrary DOM element outside of the Angular\n * application context.\n *\n * This is the only part of the portal core that directly touches the DOM.\n */\nvar DomPortalHost = /*@__PURE__*/ (function (_super) {\n    __extends(DomPortalHost, _super);\n    /**\n     * @param {?} _hostDomElement\n     * @param {?} _componentFactoryResolver\n     * @param {?} _appRef\n     */\n    function DomPortalHost(_hostDomElement, _componentFactoryResolver, _appRef) {\n        var _this = _super.call(this) || this;\n        _this._hostDomElement = _hostDomElement;\n        _this._componentFactoryResolver = _componentFactoryResolver;\n        _this._appRef = _appRef;\n        return _this;\n    }\n    /**\n     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n     * @template T\n     * @param {?} portal Portal to be attached\n     * @param {?} newestOnTop\n     * @return {?}\n     */\n    DomPortalHost.prototype.attachComponentPortal = function (portal, newestOnTop) {\n        var _this = this;\n        var /** @type {?} */ componentFactory = this._componentFactoryResolver.resolveComponentFactory(portal.component);\n        var /** @type {?} */ componentRef;\n        // If the portal specifies a ViewContainerRef, we will use that as the attachment point\n        // for the component (in terms of Angular's component tree, not rendering).\n        // When the ViewContainerRef is missing, we use the factory to create the component directly\n        // and then manually attach the ChangeDetector for that component to the application (which\n        // happens automatically when using a ViewContainer).\n        componentRef = componentFactory.create(portal.injector);\n        // When creating a component outside of a ViewContainer, we need to manually register\n        // its ChangeDetector with the application. This API is unfortunately not yet published\n        // in Angular core. The change detector must also be deregistered when the component\n        // is destroyed to prevent memory leaks.\n        this._appRef.attachView(componentRef.hostView);\n        this.setDisposeFn(function () {\n            _this._appRef.detachView(componentRef.hostView);\n            componentRef.destroy();\n        });\n        // At this point the component has been instantiated, so we move it to the location in the DOM\n        // where we want it to be rendered.\n        if (newestOnTop) {\n            this._hostDomElement.insertBefore(this._getComponentRootNode(componentRef), this._hostDomElement.firstChild);\n        }\n        else {\n            this._hostDomElement.appendChild(this._getComponentRootNode(componentRef));\n        }\n        return componentRef;\n    };\n    /**\n     * Gets the root HTMLElement for an instantiated component.\n     * @param {?} componentRef\n     * @return {?}\n     */\n    DomPortalHost.prototype._getComponentRootNode = function (componentRef) {\n        return /** @type {?} */ (((componentRef.hostView)).rootNodes[0]);\n    };\n    return DomPortalHost;\n}(BasePortalHost));\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Reference to an overlay that has been created with the Overlay service.\n * Used to manipulate or dispose of said overlay.\n */\nvar OverlayRef = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} _portalHost\n     */\n    function OverlayRef(_portalHost) {\n        this._portalHost = _portalHost;\n    }\n    /**\n     * @param {?} portal\n     * @param {?=} newestOnTop\n     * @return {?}\n     */\n    OverlayRef.prototype.attach = function (portal, newestOnTop) {\n        if (newestOnTop === void 0) {\n            newestOnTop = true;\n        }\n        return this._portalHost.attach(portal, newestOnTop);\n    };\n    /**\n     * Detaches an overlay from a portal.\n     * @return {?} Resolves when the overlay has been detached.\n     */\n    OverlayRef.prototype.detach = function () {\n        return this._portalHost.detach();\n    };\n    return OverlayRef;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * The OverlayContainer is the container in which all overlays will load.\n * It should be provided in the root component to ensure it is properly shared.\n */\nvar OverlayContainer = /*@__PURE__*/ (function () {\n    function OverlayContainer() {\n    }\n    /**\n     * This method returns the overlay container element.  It will lazily\n     * create the element the first time  it is called to facilitate using\n     * the container in non-browser environments.\n     * @return {?} the container element\n     */\n    OverlayContainer.prototype.getContainerElement = function () {\n        if (!this._containerElement) {\n            this._createContainer();\n        }\n        return this._containerElement;\n    };\n    /**\n     * Create the overlay container element, which is simply a div\n     * with the 'cdk-overlay-container' class on the document body.\n     * @return {?}\n     */\n    OverlayContainer.prototype._createContainer = function () {\n        var /** @type {?} */ container = document.createElement('div');\n        container.classList.add('overlay-container');\n        document.body.appendChild(container);\n        this._containerElement = container;\n    };\n    return OverlayContainer;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Service to create Overlays. Overlays are dynamically added pieces of floating UI, meant to be\n * used as a low-level building building block for other components. Dialogs, tooltips, menus,\n * selects, etc. can all be built using overlays. The service should primarily be used by authors\n * of re-usable components rather than developers building end-user applications.\n *\n * An overlay *is* a PortalHost, so any kind of Portal can be loaded into one.\n */\nvar Overlay = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} _overlayContainer\n     * @param {?} _componentFactoryResolver\n     * @param {?} _appRef\n     */\n    function Overlay(_overlayContainer, _componentFactoryResolver, _appRef) {\n        this._overlayContainer = _overlayContainer;\n        this._componentFactoryResolver = _componentFactoryResolver;\n        this._appRef = _appRef;\n        this._paneElements = {};\n    }\n    /**\n     * Creates an overlay.\n     * @param {?=} positionClass\n     * @param {?=} overlayContainer\n     * @return {?} A reference to the created overlay.\n     */\n    Overlay.prototype.create = function (positionClass, overlayContainer) {\n        // get existing pane if possible\n        return this._createOverlayRef(this.getPaneElement(positionClass, overlayContainer));\n    };\n    /**\n     * @param {?=} positionClass\n     * @param {?=} overlayContainer\n     * @return {?}\n     */\n    Overlay.prototype.getPaneElement = function (positionClass, overlayContainer) {\n        if (positionClass === void 0) {\n            positionClass = '';\n        }\n        if (!this._paneElements[positionClass]) {\n            this._paneElements[positionClass] = this._createPaneElement(positionClass, overlayContainer);\n        }\n        return this._paneElements[positionClass];\n    };\n    /**\n     * Creates the DOM element for an overlay and appends it to the overlay container.\n     * @param {?} positionClass\n     * @param {?=} overlayContainer\n     * @return {?} Newly-created pane element\n     */\n    Overlay.prototype._createPaneElement = function (positionClass, overlayContainer) {\n        var /** @type {?} */ pane = document.createElement('div');\n        pane.id = 'toast-container';\n        pane.classList.add(positionClass);\n        pane.classList.add('toast-container');\n        if (!overlayContainer) {\n            this._overlayContainer.getContainerElement().appendChild(pane);\n        }\n        else {\n            overlayContainer.getContainerElement().appendChild(pane);\n        }\n        return pane;\n    };\n    /**\n     * Create a DomPortalHost into which the overlay content can be loaded.\n     * @param {?} pane The DOM element to turn into a portal host.\n     * @return {?} A portal host for the given DOM element.\n     */\n    Overlay.prototype._createPortalHost = function (pane) {\n        return new DomPortalHost(pane, this._componentFactoryResolver, this._appRef);\n    };\n    /**\n     * Creates an OverlayRef for an overlay in the given DOM element.\n     * @param {?} pane DOM element for the overlay\n     * @return {?}\n     */\n    Overlay.prototype._createOverlayRef = function (pane) {\n        return new OverlayRef(this._createPortalHost(pane));\n    };\n    return Overlay;\n}());\n/**\n * Providers for Overlay and its related injectables.\n */\nvar /** @type {?} */ OVERLAY_PROVIDERS = [\n    Overlay,\n    OverlayContainer,\n];\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar ToastContainerDirective = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} el\n     */\n    function ToastContainerDirective(el) {\n        this.el = el;\n    }\n    /**\n     * @return {?}\n     */\n    ToastContainerDirective.prototype.getContainerElement = function () {\n        return this.el.nativeElement;\n    };\n    return ToastContainerDirective;\n}());\nvar ToastContainerModule = /*@__PURE__*/ (function () {\n    function ToastContainerModule() {\n    }\n    return ToastContainerModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Everything a toast needs to launch\n */\nvar ToastPackage = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} toastId\n     * @param {?} config\n     * @param {?} message\n     * @param {?} title\n     * @param {?} toastType\n     * @param {?} toastRef\n     */\n    function ToastPackage(toastId, config, message, title, toastType, toastRef) {\n        var _this = this;\n        this.toastId = toastId;\n        this.config = config;\n        this.message = message;\n        this.title = title;\n        this.toastType = toastType;\n        this.toastRef = toastRef;\n        this._onTap = new Subject();\n        this._onAction = new Subject();\n        this.toastRef.afterClosed().subscribe(function () {\n            _this._onAction.complete();\n            _this._onTap.complete();\n        });\n    }\n    /**\n     * Fired on click\n     * @return {?}\n     */\n    ToastPackage.prototype.triggerTap = function () {\n        this._onTap.next();\n        this._onTap.complete();\n    };\n    /**\n     * @return {?}\n     */\n    ToastPackage.prototype.onTap = function () {\n        return this._onTap.asObservable();\n    };\n    /**\n     * available for use in custom toast\n     * @param {?=} action\n     * @return {?}\n     */\n    ToastPackage.prototype.triggerAction = function (action) {\n        this._onAction.next(action);\n    };\n    /**\n     * @return {?}\n     */\n    ToastPackage.prototype.onAction = function () {\n        return this._onAction.asObservable();\n    };\n    return ToastPackage;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Reference to a toast opened via the Toastr service.\n * @template T\n */\nvar ToastRef = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} _overlayRef\n     */\n    function ToastRef(_overlayRef) {\n        this._overlayRef = _overlayRef;\n        /**\n         * Subject for notifying the user that the toast has finished closing.\n         */\n        this._afterClosed = new Subject();\n        /**\n         * triggered when toast is activated\n         */\n        this._activate = new Subject();\n        /**\n         * notifies the toast that it should close before the timeout\n         */\n        this._manualClose = new Subject();\n    }\n    /**\n     * @return {?}\n     */\n    ToastRef.prototype.manualClose = function () {\n        this._manualClose.next();\n        this._manualClose.complete();\n    };\n    /**\n     * @return {?}\n     */\n    ToastRef.prototype.manualClosed = function () {\n        return this._manualClose.asObservable();\n    };\n    /**\n     * Close the toast.\n     * @return {?}\n     */\n    ToastRef.prototype.close = function () {\n        this._overlayRef.detach();\n        this._afterClosed.next();\n        this._afterClosed.complete();\n        this._manualClose.complete();\n        this._activate.complete();\n    };\n    /**\n     * Gets an observable that is notified when the toast is finished closing.\n     * @return {?}\n     */\n    ToastRef.prototype.afterClosed = function () {\n        return this._afterClosed.asObservable();\n    };\n    /**\n     * @return {?}\n     */\n    ToastRef.prototype.isInactive = function () {\n        return this._activate.isStopped;\n    };\n    /**\n     * @return {?}\n     */\n    ToastRef.prototype.activate = function () {\n        this._activate.next();\n        this._activate.complete();\n    };\n    /**\n     * Gets an observable that is notified when the toast has started opening.\n     * @return {?}\n     */\n    ToastRef.prototype.afterActivate = function () {\n        return this._activate.asObservable();\n    };\n    return ToastRef;\n}());\n/**\n * Custom injector type specifically for instantiating components with a toast.\n */\nvar ToastInjector = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} _toastPackage\n     * @param {?} _parentInjector\n     */\n    function ToastInjector(_toastPackage, _parentInjector) {\n        this._toastPackage = _toastPackage;\n        this._parentInjector = _parentInjector;\n    }\n    /**\n     * @param {?} token\n     * @param {?=} notFoundValue\n     * @return {?}\n     */\n    ToastInjector.prototype.get = function (token, notFoundValue) {\n        if (token === ToastPackage && this._toastPackage) {\n            return this._toastPackage;\n        }\n        return this._parentInjector.get(token, notFoundValue);\n    };\n    return ToastInjector;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar /** @type {?} */ TOAST_CONFIG = /*@__PURE__*/ new InjectionToken('ToastConfig');\nvar ToastrService = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} token\n     * @param {?} overlay\n     * @param {?} _injector\n     * @param {?} sanitizer\n     * @param {?} ngZone\n     */\n    function ToastrService(token, overlay, _injector, sanitizer, ngZone) {\n        this.overlay = overlay;\n        this._injector = _injector;\n        this.sanitizer = sanitizer;\n        this.ngZone = ngZone;\n        this.currentlyActive = 0;\n        this.toasts = [];\n        this.index = 0;\n        var /** @type {?} */ defaultConfig = new token.defaults;\n        this.toastrConfig = Object.assign({}, defaultConfig, token.config);\n        this.toastrConfig.iconClasses = Object.assign({}, defaultConfig.iconClasses, token.config.iconClasses);\n    }\n    /**\n     * show toast\n     * @param {?=} message\n     * @param {?=} title\n     * @param {?=} override\n     * @param {?=} type\n     * @return {?}\n     */\n    ToastrService.prototype.show = function (message, title, override, type) {\n        if (override === void 0) {\n            override = {};\n        }\n        if (type === void 0) {\n            type = '';\n        }\n        return this._preBuildNotification(type, message, title, this.applyConfig(override));\n    };\n    /**\n     * show successful toast\n     * @param {?=} message\n     * @param {?=} title\n     * @param {?=} override\n     * @return {?}\n     */\n    ToastrService.prototype.success = function (message, title, override) {\n        if (override === void 0) {\n            override = {};\n        }\n        var /** @type {?} */ type = this.toastrConfig.iconClasses.success || '';\n        return this._preBuildNotification(type, message, title, this.applyConfig(override));\n    };\n    /**\n     * show error toast\n     * @param {?=} message\n     * @param {?=} title\n     * @param {?=} override\n     * @return {?}\n     */\n    ToastrService.prototype.error = function (message, title, override) {\n        if (override === void 0) {\n            override = {};\n        }\n        var /** @type {?} */ type = this.toastrConfig.iconClasses.error || '';\n        return this._preBuildNotification(type, message, title, this.applyConfig(override));\n    };\n    /**\n     * show info toast\n     * @param {?=} message\n     * @param {?=} title\n     * @param {?=} override\n     * @return {?}\n     */\n    ToastrService.prototype.info = function (message, title, override) {\n        if (override === void 0) {\n            override = {};\n        }\n        var /** @type {?} */ type = this.toastrConfig.iconClasses.info || '';\n        return this._preBuildNotification(type, message, title, this.applyConfig(override));\n    };\n    /**\n     * show warning toast\n     * @param {?=} message\n     * @param {?=} title\n     * @param {?=} override\n     * @return {?}\n     */\n    ToastrService.prototype.warning = function (message, title, override) {\n        if (override === void 0) {\n            override = {};\n        }\n        var /** @type {?} */ type = this.toastrConfig.iconClasses.warning || '';\n        return this._preBuildNotification(type, message, title, this.applyConfig(override));\n    };\n    /**\n     * Remove all or a single toast by id\n     * @param {?=} toastId\n     * @return {?}\n     */\n    ToastrService.prototype.clear = function (toastId) {\n        try {\n            // Call every toastRef manualClose function\n            for (var _a = __values(this.toasts), _b = _a.next(); !_b.done; _b = _a.next()) {\n                var toast = _b.value;\n                if (toastId !== undefined) {\n                    if (toast.toastId === toastId) {\n                        toast.toastRef.manualClose();\n                        return;\n                    }\n                }\n                else {\n                    toast.toastRef.manualClose();\n                }\n            }\n        }\n        catch (e_1_1) {\n            e_1 = { error: e_1_1 };\n        }\n        finally {\n            try {\n                if (_b && !_b.done && (_c = _a.return))\n                    _c.call(_a);\n            }\n            finally {\n                if (e_1)\n                    throw e_1.error;\n            }\n        }\n        var e_1, _c;\n    };\n    /**\n     * Remove and destroy a single toast by id\n     * @param {?} toastId\n     * @return {?}\n     */\n    ToastrService.prototype.remove = function (toastId) {\n        var /** @type {?} */ found = this._findToast(toastId);\n        if (!found) {\n            return false;\n        }\n        found.activeToast.toastRef.close();\n        this.toasts.splice(found.index, 1);\n        this.currentlyActive = this.currentlyActive - 1;\n        if (!this.toastrConfig.maxOpened || !this.toasts.length) {\n            return false;\n        }\n        if (this.currentlyActive < this.toastrConfig.maxOpened && this.toasts[this.currentlyActive]) {\n            var /** @type {?} */ p = this.toasts[this.currentlyActive].toastRef;\n            if (!p.isInactive()) {\n                this.currentlyActive = this.currentlyActive + 1;\n                p.activate();\n            }\n        }\n        return true;\n    };\n    /**\n     * Determines if toast message is already shown\n     * @param {?} message\n     * @return {?}\n     */\n    ToastrService.prototype.isDuplicate = function (message) {\n        for (var /** @type {?} */ i = 0; i < this.toasts.length; i++) {\n            if (this.toasts[i].message === message) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * create a clone of global config and apply individual settings\n     * @param {?=} override\n     * @return {?}\n     */\n    ToastrService.prototype.applyConfig = function (override) {\n        if (override === void 0) {\n            override = {};\n        }\n        return Object.assign({}, this.toastrConfig, override);\n    };\n    /**\n     * Find toast object by id\n     * @param {?} toastId\n     * @return {?}\n     */\n    ToastrService.prototype._findToast = function (toastId) {\n        for (var /** @type {?} */ i = 0; i < this.toasts.length; i++) {\n            if (this.toasts[i].toastId === toastId) {\n                return { index: i, activeToast: this.toasts[i] };\n            }\n        }\n        return null;\n    };\n    /**\n     * Determines the need to run inside angular's zone then builds the toast\n     * @param {?} toastType\n     * @param {?} message\n     * @param {?} title\n     * @param {?} config\n     * @return {?}\n     */\n    ToastrService.prototype._preBuildNotification = function (toastType, message, title, config) {\n        var _this = this;\n        if (config.onActivateTick) {\n            return this.ngZone.run(function () { return _this._buildNotification(toastType, message, title, config); });\n        }\n        return this._buildNotification(toastType, message, title, config);\n    };\n    /**\n     * Creates and attaches toast data to component\n     * returns null if toast is duplicate and preventDuplicates == True\n     * @param {?} toastType\n     * @param {?} message\n     * @param {?} title\n     * @param {?} config\n     * @return {?}\n     */\n    ToastrService.prototype._buildNotification = function (toastType, message, title, config) {\n        var _this = this;\n        if (!config.toastComponent) {\n            throw new Error('toastComponent required');\n        }\n        // max opened and auto dismiss = true\n        if (message && this.toastrConfig.preventDuplicates && this.isDuplicate(message)) {\n            return null;\n        }\n        this.previousToastMessage = message;\n        var /** @type {?} */ keepInactive = false;\n        if (this.toastrConfig.maxOpened && this.currentlyActive >= this.toastrConfig.maxOpened) {\n            keepInactive = true;\n            if (this.toastrConfig.autoDismiss) {\n                this.clear(this.toasts[this.toasts.length - 1].toastId);\n            }\n        }\n        var /** @type {?} */ overlayRef = this.overlay.create(config.positionClass, this.overlayContainer);\n        this.index = this.index + 1;\n        var /** @type {?} */ sanitizedMessage = message;\n        if (message && config.enableHtml) {\n            sanitizedMessage = this.sanitizer.sanitize(SecurityContext.HTML, message);\n        }\n        var /** @type {?} */ toastRef = new ToastRef(overlayRef);\n        var /** @type {?} */ toastPackage = new ToastPackage(this.index, config, sanitizedMessage, title, toastType, toastRef);\n        var /** @type {?} */ toastInjector = new ToastInjector(toastPackage, this._injector);\n        var /** @type {?} */ component = new ComponentPortal(config.toastComponent, toastInjector);\n        var /** @type {?} */ portal = overlayRef.attach(component, this.toastrConfig.newestOnTop);\n        toastRef.componentInstance = ((portal))._component;\n        var /** @type {?} */ ins = {\n            toastId: this.index,\n            message: message || '',\n            toastRef: toastRef,\n            onShown: toastRef.afterActivate(),\n            onHidden: toastRef.afterClosed(),\n            onTap: toastPackage.onTap(),\n            onAction: toastPackage.onAction(),\n            portal: portal,\n        };\n        if (!keepInactive) {\n            setTimeout(function () {\n                ins.toastRef.activate();\n                _this.currentlyActive = _this.currentlyActive + 1;\n            });\n        }\n        this.toasts.push(ins);\n        return ins;\n    };\n    return ToastrService;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar Toast = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} toastrService\n     * @param {?} toastPackage\n     * @param {?=} ngZone\n     */\n    function Toast(toastrService, toastPackage, ngZone) {\n        var _this = this;\n        this.toastrService = toastrService;\n        this.toastPackage = toastPackage;\n        this.ngZone = ngZone;\n        /**\n         * width of progress bar\n         */\n        this.width = -1;\n        /**\n         * a combination of toast type and options.toastClass\n         */\n        this.toastClasses = '';\n        /**\n         * controls animation\n         */\n        this.state = {\n            value: 'inactive',\n            params: {\n                easeTime: this.toastPackage.config.easeTime,\n                easing: 'ease-in',\n            },\n        };\n        this.message = toastPackage.message;\n        this.title = toastPackage.title;\n        this.options = toastPackage.config;\n        this.toastClasses = toastPackage.toastType + \" \" + toastPackage.config.toastClass;\n        this.sub = toastPackage.toastRef.afterActivate().subscribe(function () {\n            _this.activateToast();\n        });\n        this.sub1 = toastPackage.toastRef.manualClosed().subscribe(function () {\n            _this.remove();\n        });\n    }\n    /**\n     * @return {?}\n     */\n    Toast.prototype.ngOnDestroy = function () {\n        this.sub.unsubscribe();\n        this.sub1.unsubscribe();\n        clearInterval(this.intervalId);\n        clearTimeout(this.timeout);\n    };\n    /**\n     * activates toast and sets timeout\n     * @return {?}\n     */\n    Toast.prototype.activateToast = function () {\n        var _this = this;\n        this.state = Object.assign({}, this.state, { value: 'active' });\n        if (!this.options.disableTimeOut && this.options.timeOut) {\n            this.outsideTimeout(function () { return _this.remove(); }, this.options.timeOut);\n            this.hideTime = new Date().getTime() + this.options.timeOut;\n            if (this.options.progressBar) {\n                this.outsideInterval(function () { return _this.updateProgress(); }, 10);\n            }\n        }\n    };\n    /**\n     * updates progress bar width\n     * @return {?}\n     */\n    Toast.prototype.updateProgress = function () {\n        if (this.width === 0 || this.width === 100 || !this.options.timeOut) {\n            return;\n        }\n        var /** @type {?} */ now = new Date().getTime();\n        var /** @type {?} */ remaining = this.hideTime - now;\n        this.width = (remaining / this.options.timeOut) * 100;\n        if (this.options.progressAnimation === 'increasing') {\n            this.width = 100 - this.width;\n        }\n        if (this.width <= 0) {\n            this.width = 0;\n        }\n        if (this.width >= 100) {\n            this.width = 100;\n        }\n    };\n    /**\n     * tells toastrService to remove this toast after animation time\n     * @return {?}\n     */\n    Toast.prototype.remove = function () {\n        var _this = this;\n        if (this.state.value === 'removed') {\n            return;\n        }\n        clearTimeout(this.timeout);\n        this.state = Object.assign({}, this.state, { value: 'removed' });\n        this.outsideTimeout(function () { return _this.toastrService.remove(_this.toastPackage.toastId); }, +this.toastPackage.config.easeTime);\n    };\n    /**\n     * @return {?}\n     */\n    Toast.prototype.tapToast = function () {\n        if (this.state.value === 'removed') {\n            return;\n        }\n        this.toastPackage.triggerTap();\n        if (this.options.tapToDismiss) {\n            this.remove();\n        }\n    };\n    /**\n     * @return {?}\n     */\n    Toast.prototype.stickAround = function () {\n        if (this.state.value === 'removed') {\n            return;\n        }\n        clearTimeout(this.timeout);\n        this.options.timeOut = 0;\n        this.hideTime = 0;\n        // disable progressBar\n        clearInterval(this.intervalId);\n        this.width = 0;\n    };\n    /**\n     * @return {?}\n     */\n    Toast.prototype.delayedHideToast = function () {\n        var _this = this;\n        if (this.options.disableTimeOut\n            || this.options.extendedTimeOut === 0\n            || this.state.value === 'removed') {\n            return;\n        }\n        this.outsideTimeout(function () { return _this.remove(); }, this.options.extendedTimeOut);\n        this.options.timeOut = this.options.extendedTimeOut;\n        this.hideTime = new Date().getTime() + (this.options.timeOut || 0);\n        this.width = -1;\n        if (this.options.progressBar) {\n            this.outsideInterval(function () { return _this.updateProgress(); }, 10);\n        }\n    };\n    /**\n     * @param {?} func\n     * @param {?} timeout\n     * @return {?}\n     */\n    Toast.prototype.outsideTimeout = function (func, timeout) {\n        var _this = this;\n        if (this.ngZone) {\n            this.ngZone.runOutsideAngular(function () { return _this.timeout = setTimeout(function () { return _this.runInsideAngular(func); }, timeout); });\n        }\n        else {\n            this.timeout = setTimeout(function () { return func(); }, timeout);\n        }\n    };\n    /**\n     * @param {?} func\n     * @param {?} timeout\n     * @return {?}\n     */\n    Toast.prototype.outsideInterval = function (func, timeout) {\n        var _this = this;\n        if (this.ngZone) {\n            this.ngZone.runOutsideAngular(function () { return _this.intervalId = setInterval(function () { return _this.runInsideAngular(func); }, timeout); });\n        }\n        else {\n            this.intervalId = setInterval(function () { return func(); }, timeout);\n        }\n    };\n    /**\n     * @param {?} func\n     * @return {?}\n     */\n    Toast.prototype.runInsideAngular = function (func) {\n        if (this.ngZone) {\n            this.ngZone.run(function () { return func(); });\n        }\n        else {\n            func();\n        }\n    };\n    return Toast;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar DefaultGlobalConfig = /*@__PURE__*/ (function () {\n    function DefaultGlobalConfig() {\n        // Global\n        this.maxOpened = 0;\n        this.autoDismiss = false;\n        this.newestOnTop = true;\n        this.preventDuplicates = false;\n        this.iconClasses = {\n            error: 'toast-error',\n            info: 'toast-info',\n            success: 'toast-success',\n            warning: 'toast-warning',\n        };\n        // Individual\n        this.toastComponent = Toast;\n        this.closeButton = false;\n        this.timeOut = 5000;\n        this.extendedTimeOut = 1000;\n        this.enableHtml = false;\n        this.progressBar = false;\n        this.toastClass = 'toast';\n        this.positionClass = 'toast-top-right';\n        this.titleClass = 'toast-title';\n        this.messageClass = 'toast-message';\n        this.easing = 'ease-in';\n        this.easeTime = 300;\n        this.tapToDismiss = true;\n        this.onActivateTick = false;\n        this.progressAnimation = 'decreasing';\n    }\n    return DefaultGlobalConfig;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar ToastrModule = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} parentModule\n     */\n    function ToastrModule(parentModule) {\n        if (parentModule) {\n            throw new Error('ToastrModule is already loaded. It should only be imported in your application\\'s main module.');\n        }\n    }\n    /**\n     * @param {?=} config\n     * @return {?}\n     */\n    ToastrModule.forRoot = function (config) {\n        if (config === void 0) {\n            config = {};\n        }\n        return {\n            ngModule: ToastrModule,\n            providers: [\n                { provide: TOAST_CONFIG, useValue: { config: config, defaults: DefaultGlobalConfig } },\n                OverlayContainer,\n                Overlay,\n                ToastrService,\n            ],\n        };\n    };\n    return ToastrModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar ToastNoAnimation = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} toastrService\n     * @param {?} toastPackage\n     * @param {?} appRef\n     */\n    function ToastNoAnimation(toastrService, toastPackage, appRef) {\n        var _this = this;\n        this.toastrService = toastrService;\n        this.toastPackage = toastPackage;\n        this.appRef = appRef;\n        /**\n         * width of progress bar\n         */\n        this.width = -1;\n        /**\n         * a combination of toast type and options.toastClass\n         */\n        this.toastClasses = '';\n        /**\n         * controls animation\n         */\n        this.state = 'inactive';\n        this.message = toastPackage.message;\n        this.title = toastPackage.title;\n        this.options = toastPackage.config;\n        this.toastClasses = toastPackage.toastType + \" \" + toastPackage.config.toastClass;\n        this.sub = toastPackage.toastRef.afterActivate().subscribe(function () {\n            _this.activateToast();\n        });\n        this.sub1 = toastPackage.toastRef.manualClosed().subscribe(function () {\n            _this.remove();\n        });\n    }\n    Object.defineProperty(ToastNoAnimation.prototype, \"displayStyle\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            if (this.state === 'inactive') {\n                return 'none';\n            }\n            return 'inherit';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    ToastNoAnimation.prototype.ngOnDestroy = function () {\n        this.sub.unsubscribe();\n        this.sub1.unsubscribe();\n        clearInterval(this.intervalId);\n        clearTimeout(this.timeout);\n    };\n    /**\n     * activates toast and sets timeout\n     * @return {?}\n     */\n    ToastNoAnimation.prototype.activateToast = function () {\n        var _this = this;\n        this.state = 'active';\n        if (!this.options.disableTimeOut && this.options.timeOut) {\n            this.timeout = setTimeout(function () {\n                _this.remove();\n            }, this.options.timeOut);\n            this.hideTime = new Date().getTime() + this.options.timeOut;\n            if (this.options.progressBar) {\n                this.intervalId = setInterval(function () { return _this.updateProgress(); }, 10);\n            }\n        }\n        if (this.options.onActivateTick) {\n            this.appRef.tick();\n        }\n    };\n    /**\n     * updates progress bar width\n     * @return {?}\n     */\n    ToastNoAnimation.prototype.updateProgress = function () {\n        if (this.width === 0 || this.width === 100 || !this.options.timeOut) {\n            return;\n        }\n        var /** @type {?} */ now = new Date().getTime();\n        var /** @type {?} */ remaining = this.hideTime - now;\n        this.width = remaining / this.options.timeOut * 100;\n        if (this.options.progressAnimation === 'increasing') {\n            this.width = 100 - this.width;\n        }\n        if (this.width <= 0) {\n            this.width = 0;\n        }\n        if (this.width >= 100) {\n            this.width = 100;\n        }\n    };\n    /**\n     * tells toastrService to remove this toast after animation time\n     * @return {?}\n     */\n    ToastNoAnimation.prototype.remove = function () {\n        var _this = this;\n        if (this.state === 'removed') {\n            return;\n        }\n        clearTimeout(this.timeout);\n        this.state = 'removed';\n        this.timeout = setTimeout(function () { return _this.toastrService.remove(_this.toastPackage.toastId); });\n    };\n    /**\n     * @return {?}\n     */\n    ToastNoAnimation.prototype.tapToast = function () {\n        if (this.state === 'removed') {\n            return;\n        }\n        this.toastPackage.triggerTap();\n        if (this.options.tapToDismiss) {\n            this.remove();\n        }\n    };\n    /**\n     * @return {?}\n     */\n    ToastNoAnimation.prototype.stickAround = function () {\n        if (this.state === 'removed') {\n            return;\n        }\n        clearTimeout(this.timeout);\n        this.options.timeOut = 0;\n        this.hideTime = 0;\n        // disable progressBar\n        clearInterval(this.intervalId);\n        this.width = 0;\n    };\n    /**\n     * @return {?}\n     */\n    ToastNoAnimation.prototype.delayedHideToast = function () {\n        var _this = this;\n        if (this.options.disableTimeOut\n            || this.options.extendedTimeOut === 0\n            || this.state === 'removed') {\n            return;\n        }\n        this.timeout = setTimeout(function () { return _this.remove(); }, this.options.extendedTimeOut);\n        this.options.timeOut = this.options.extendedTimeOut;\n        this.hideTime = new Date().getTime() + (this.options.timeOut || 0);\n        this.width = -1;\n        if (this.options.progressBar) {\n            this.intervalId = setInterval(function () { return _this.updateProgress(); }, 10);\n        }\n    };\n    return ToastNoAnimation;\n}());\nvar ToastNoAnimationModule = /*@__PURE__*/ (function () {\n    function ToastNoAnimationModule() {\n    }\n    return ToastNoAnimationModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nexport { ComponentPortal, BasePortalHost, Overlay, OVERLAY_PROVIDERS, OverlayContainer, OverlayRef, ToastContainerDirective, ToastContainerModule, Toast, ToastrService, ToastPackage, DefaultGlobalConfig, ToastrModule, ToastRef, ToastInjector, TOAST_CONFIG, ToastNoAnimation, ToastNoAnimationModule };\n//# sourceMappingURL=ngx-toastr.js.map\n",null]}